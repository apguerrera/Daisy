import { compileAndLoadCircuit } from '../'
import { config } from 'maci-config'
import { MaciState } from 'maci-core'

import {
    Keypair,
    StateLeaf,
    Command,
    Message,
} from 'maci-domainobjs'

import {
    genRandomSalt,
    bigInt,
} from 'maci-crypto'

jest.setTimeout(1200000)

const batchSize = config.maci.messageBatchSize
const stateTreeDepth = config.maci.merkleTrees.stateTreeDepth
const messageTreeDepth = config.maci.merkleTrees.messageTreeDepth
const voteOptionTreeDepth = config.maci.merkleTrees.voteOptionTreeDepth
const voteOptionsMaxIndex = config.maci.voteOptionsMaxLeafIndex
const initialVoiceCreditBalance = config.maci.initialVoiceCreditBalance


// Set up keypairs
const user = new Keypair()
const coordinator = new Keypair()

describe('State tree root update verification circuit', () => {
    let circuit 
    const voteWeight = bigInt(2)

    const maciState = new MaciState(
        coordinator,
        stateTreeDepth,
        messageTreeDepth,
        voteOptionTreeDepth,
        voteOptionsMaxIndex,
    )

    beforeAll(async () => {
        circuit = await compileAndLoadCircuit('test/batchUpdateStateTree_test.circom')

        // Sign up the user
        maciState.signUp(user.pubKey, initialVoiceCreditBalance)
    })

    it('BatchUpdateStateTree should produce the correct state root from a partially filled batch', async () => {
        const stateRootBefore = maciState.genStateRoot()

        const command = new Command(
            bigInt(1),
            user.pubKey,
            bigInt(0),
            voteWeight,
            bigInt(1),
            genRandomSalt(),
        )
        const signature = command.sign(user.privKey)
        const sharedKey = Keypair.genEcdhSharedKey(user.privKey, coordinator.pubKey)
        const message = command.encrypt(signature, sharedKey)

        maciState.publishMessage(message, user.pubKey)

        const randomStateLeaf = StateLeaf.genRandomLeaf()

        // Generate circuit inputs
        const circuitInputs = 
            maciState.genBatchUpdateStateTreeCircuitInputs(
                0,
                batchSize,
                randomStateLeaf,
            )

        // Calculate the witness
        const witness = circuit.calculateWitness(circuitInputs)
        expect(circuit.checkWitness(witness)).toBeTruthy()

        // Get the circuit-generated root
        const idx = circuit.getSignalIdx('main.root')
        const circuitNewStateRoot = witness[idx].toString()

        // Process the batch of messages
        maciState.batchProcessMessage(
            0,
            batchSize,
            randomStateLeaf,
        )

        const stateRootAfter = maciState.genStateRoot()

        expect(stateRootBefore.toString()).not.toEqual(stateRootAfter)

        // After we run process the message via maciState.processMessage(),
        // the root generated by the circuit should match
        expect(circuitNewStateRoot.toString()).toEqual(stateRootAfter.toString())
    })

    it('BatchUpdateStateTree should produce the correct state root from a full batch', async () => {
        // Generate a batch of valid messages from the same user
        const messages: Message[] = []
        const stateRootBefore = maciState.genStateRoot()

        for (let i = 0; i < batchSize; i++) {
            const command = new Command(
                bigInt(1),
                user.pubKey,
                bigInt(0),
                voteWeight,
                bigInt(i + 1),
                genRandomSalt(),
            )
            const signature = command.sign(user.privKey)
            const sharedKey = Keypair.genEcdhSharedKey(user.privKey, coordinator.pubKey)
            const message = command.encrypt(signature, sharedKey)

            messages.push(message)

            maciState.publishMessage(message, user.pubKey)
        }

        const randomStateLeaf = StateLeaf.genRandomLeaf()

        // Generate circuit inputs
        const circuitInputs = 
            maciState.genBatchUpdateStateTreeCircuitInputs(
                0,
                batchSize,
                randomStateLeaf,
            )

        // Calculate the witness
        const witness = circuit.calculateWitness(circuitInputs)
        expect(circuit.checkWitness(witness)).toBeTruthy()

        // Get the circuit-generated root
        const idx = circuit.getSignalIdx('main.root')
        const circuitNewStateRoot = witness[idx].toString()

        // Process the batch of messages
        maciState.batchProcessMessage(
            0,
            batchSize,
            randomStateLeaf,
        )

        const stateRootAfter = maciState.genStateRoot()

        expect(stateRootBefore.toString()).not.toEqual(stateRootAfter)

        // After we run process the message via maciState.processMessage(),
        // the root generated by the circuit should match
        expect(circuitNewStateRoot.toString()).toEqual(stateRootAfter.toString())
    })
})
